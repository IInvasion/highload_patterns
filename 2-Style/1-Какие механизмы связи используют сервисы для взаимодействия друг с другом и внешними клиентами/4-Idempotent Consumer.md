Паттерн "Идемпотентный потребитель" (Idempotent Consumer) описывает подход к обработке сообщений в микросервисной архитектуре, который позволяет корректно обрабатывать дублирующиеся сообщения.

## Контекст

В корпоративных приложениях использование брокера сообщений с гарантией "по крайней мере один раз" (at-least once) является распространенной практикой. Эта гарантия означает, что брокер сообщений будет доставлять сообщения потребителю даже в случае возникновения ошибок. Однако это может привести к тому, что один и тот же потребитель будет многократно вызываться для обработки одного и того же сообщения.

## Проблема

Основная задача заключается в том, как потребитель сообщений может правильно обрабатывать дублирующиеся сообщения.

## Решение

Решение состоит в реализации идемпотентного потребителя, который способен корректно обрабатывать дублирующиеся сообщения. Некоторые потребители по своей природе являются идемпотентными, тогда как другим необходимо отслеживать обработанные сообщения, чтобы выявлять и игнорировать дубликаты.

## Способы реализации идемпотентности:

- **Запись идентификаторов сообщений**: Потребитель может записывать в базу данных идентификаторы успешно обработанных сообщений. При обработке нового сообщения потребитель может проверить базу данных на наличие дубликатов.
- **Хранение идентификаторов**: Идентификаторы можно хранить в отдельной таблице `PROCESSED_MESSAGES` или в бизнес-сущностях, которые создаются или обновляются.

## Связанные паттерны

- Фреймворк Eventuate реализует этот паттерн.

Этот паттерн позволяет избежать ошибок и некорректного поведения при повторной обработке сообщений, обеспечивая надежность и согласованность системы.

[Ссылка на источник](https://microservices.io/patterns/communication-style/idempotent-consumer.html)